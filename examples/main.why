const PI: f64 = 3.1415;

fn add(x: i64, y: i64): i64 {
    x + y
}

fn explicit_return_add(x: i64, y: i64): i64 {
    return x + y;
}

struct TestStruct {
    x: i64;
    bar: (i64, i64) -> i64;
}

struct Bar {
    t: TestStruct;
}

instance TestStruct {
    fn get_x(): i64 {
        this.x
    }
}

fn takes_function(func: (i64, i64) -> i64): i64 {
    func(42, 69)
}

fn main(): void {
    let a = add(42, 1337);

    let arr = [42, 1337];

    let arr2 = [1337; 5];

    let b = explicit_return_add(arr[0], arr2[3]);

    let my_struct = TestStruct {
        x: 42,
        bar: add
    };

    let value_of_x = my_struct.get_x();
    // let _ = \(x, y) => x + y;

    let mut i = 0;

    while (i < 10) {
        i = i + 1;
    }

    // my_struct.x = 1337;

    takes_function(add);
    takes_function(explicit_return_add);

    let b = Bar {
        t: TestStruct {
            x: 1337,
            bar: add
        }
    };

    b.t.x = 42;

    arr[5] = 1337;

    b.t.bar(4, 2);

    asd().x;
}

fn asd(): TestStruct {
    TestStruct {
        x: 42,
        bar: add
    }
}
